#!/usr/bin/env perl


=head1 NAME

freebox - Plugin for monitoring Freebox parameters.

=head1 APPLICABLE SYSTEMS

Any computer that has access to a Freebox v6. Perl module L<WWW::FBX>
is required for this plugin to function and can be installed from CPAN.

=head1 INSTALLATION

    apt install munin-node
    apt install munin #only if you intend to run munin on the same host

Keep in mind that WWW::FBX should be reachable from root user (either through local::lib or system install). Munin drops privileges with seteuid POSIX call.

    cpan install WWW::FBX
    git clone https://github.com/architek/Munin-Plugin-Freebox.git

=head1 CONFIGURATION

Create links of what you want to plot

    sudo ln -s "$(pwd)/Munin-Plugin-Freebox/freebox_" /etc/munin/plugins/freebox_bandwidth
    sudo ln -s "$(pwd)/Munin-Plugin-Freebox/freebox_" /etc/munin/plugins/freebox_freeplug
    sudo ln -s "$(pwd)/Munin-Plugin-Freebox/freebox_" /etc/munin/plugins/freebox_temp
    sudo ln -s "$(pwd)/Munin-Plugin-Freebox/freebox_" /etc/munin/plugins/freebox_switch1

Or use a multi graph call (the script will only be called once). Adapt @multi array to select what to plot.

    sudo ln -s "$(pwd)/Munin-Plugin-Freebox/freebox_" /etc/munin/plugins/freebox_multi

Now auto configure. This will request app\_token and track\_id from the Freebox itself.

    sudo munin-run --debug freebox_bandwidth autoconf

Add a freebox section in /etc/munin/plugin-conf.d/munin-node with values provided

    [freebox_*]
    user foo
    env.app_token value-of-the-token
    env.track_id value-of-the-track_id

Check everything is working with

    munin-run --debug freebox_bandwidth
    munin-run --debug freebox_freeplug
    munin-run --debug freebox_temp
    munin-run --debug freebox_switch1

=head1 USAGE

This is a wildcard plugin which can be used to monitor several different
families of Freebox parameters. Run it with C<suggest> command line argument
to see all the possible operation modes and create a symlink called
C<freebox_mode> to this plugin from the Munin plugins directory, e.g.
C<freebox_temp>.

=head1 AUTHORS

Copyright 2014 Vadim Zeitlin <vz-cpan@zeitlins.org>

=head1 LICENSE

GPLv2

=head1 HISTORY

=over 4

=item 2014-07-19 Initial version.

=item 2016-05-11 Modified.

=back

=cut

use strict;
use warnings;
use Munin::Plugin;
use WWW::FBX;

my @multi;

#line stats
@multi = qw/ uptime bandwidth fec_up fec_down snr up down/;
#full
@multi = qw/ fec uptime bandwidth fec_up fec_down snr up down freeplug attn switch_1 switch_2 switch_3 switch_4 temp btrate_up btrate_down comb_down comb_up/;
#full 2
@multi = qw/ fec uptime bandwidth fec_up fec_down snr up down freeplug attn temp/;

my ($app_id, $app_name, $app_version, $device_name) = ('APP ID', 'APP NAME', '1.0', 'debian');
my @modes = ( @multi, 'multi' );
my $switch_port;

sub get_freebox {
    if (!defined($ENV{app_token})) {
        die <<EOF
Please autoconf the plugin and fill in your configuration app_token
    [freebox_*]
    env.app_token   value-of-the-token
    env.track_id    value-of-track-id

to use this plugin.
EOF
    }
    WWW::FBX->new(
                app_id => $app_id,
                app_name => $app_name,
                app_version => $app_version,
                device_name => $device_name,
                track_id => $ENV{track_id},
                app_token => $ENV{app_token},
            );
}


if (defined $ARGV[0] and $ARGV[0] eq 'autoconf') {
    my $error;
    eval {
        require WWW::FBX;
        require Scalar::Util;
        my $fbx=WWW::FBX->new(app_id=>$app_id,app_name=>$app_name,app_version=>$app_version,device_name=>$device_name);
        my $app_token = $fbx->app_token;
        my $track_id = $fbx->track_id;

        print <<EOF
Now add these lines to the munin node configuration (/etc/munin/plugin-conf.d/munin-node)
[freebox_*]
env.app_token $app_token
env.track_id $track_id
EOF
    };
    if ($error = $@) {
        $error = $error->error if Scalar::Util::blessed($error) and $error->isa('WWW::FBX::Error');
    }
    print "Couldn't connect to Freebox error is $error\n" if $error;
    exit 0
}


if (defined $ARGV[0] and $ARGV[0] eq 'suggest') {
    print "$_\n" for @modes;

    exit 0
}


if ($0 !~ /freebox_(.+)*$/ or !grep /$1/, @modes) {
    die "Plugin was called with $0, must be called freebox_{" . join('|',@modes) . "}.\n"
}

my $mode = $1;

my %is_multi = map { $_ => 1 } @multi;

$switch_port = $1 if $0 =~ /freebox_switch(.*)/;

my %temps = (
        cpum => 'CPU (Marvell)',
        cpub => 'CPU (Broadcom)',
        sw   => 'switch',
    );

sub shall_print {
  my ($mode, $pat) = @_;
  $mode eq $pat or $is_multi{$pat} ? 1:0;
}

if (defined $ARGV[0] and $ARGV[0] eq 'config') {

    if ( shall_print( $mode, 'temp' ) ){
        print "multigraph freebox_temp\n" if $mode eq 'multi';
        print "graph_args --base 1000 -l 0\n";
        print "graph_title Freebox temperatures\n";
        print "graph_vlabel degrees Celsius\n";
        print "graph_category freebox\n";

        for my $t (keys %temps) {
            print "$t.label $temps{$t}\n";
            print "$t.warning 80\n";
            print "$t.critical 90\n";
        }
    }
    if ( shall_print( $mode, 'bandwidth' ) ){
        print "multigraph freebox_bandwidth\n" if $mode eq 'multi';
        print "graph_title Freebox bandwidth\n";
        print "graph_vlabel Byte / second\n";
        print "graph_category xdsl\n";
        print "bandwidth_up.label bandwidth up\n";
        print "bandwidth_down.label bandwidth down\n";
    }
    if ( shall_print( $mode, 'comb_down' ) ){
        print "multigraph freebox_comb_down\n" if $mode eq 'multi';
        print "graph_title Freebox Combined down rate\n";
        print "graph_vlabel Byte / second\n";
        print "graph_category bandwidth\n";
        print "rate_down.label rate down\n";
        print "btrate_down.label bittorrent down\n";
    }
    if ( shall_print( $mode, 'comb_up' ) ){
        print "multigraph freebox_comb_up\n" if $mode eq 'multi';
        print "graph_title Freebox Combined up rate\n";
        print "graph_vlabel Byte / second\n";
        print "graph_category bandwidth\n";
        print "rate_up.label rate up\n";
        print "btrate_up.label bittorrent up\n";
    }
    if ( shall_print( $mode, 'btrate_up' ) ){
        print "multigraph freebox_btrate_up\n" if $mode eq 'multi';
        print "graph_title Freebox Bittorrent up rate\n";
        print "graph_vlabel Byte / second\n";
        print "graph_category bandwidth\n";
        print "btrate_up.label bittorrent up\n";
        print "btrate_upthr.label bittorrent up throttle\n";
    }
    if ( shall_print( $mode, 'btrate_down' ) ){
        print "multigraph freebox_btrate_down\n" if $mode eq 'multi';
        print "graph_title Freebox Bittorrent down rate\n";
        print "graph_vlabel Byte / second\n";
        print "graph_category bandwidth\n";
        print "btrate_down.label bittorrent down\n";
        print "btrate_downthr.label bittorrent down throttle\n";
    }
    if ( shall_print( $mode, 'up' ) ){
        print "multigraph freebox_up\n" if $mode eq 'multi';
        print "graph_title Freebox bandwidth uplink\n";
        print "graph_vlabel Byte / second\n";
        print "graph_category bandwidth\n";
        print "rate_up.label rate up\n";
        print "rate_up.draw AREA\n";
    }
    if ( shall_print( $mode, 'down' ) ){
        print "multigraph freebox_down\n" if $mode eq 'multi';
        print "graph_title Freebox bandwidth downlink\n";
        print "graph_vlabel Byte / second\n";
        print "graph_category bandwidth\n";
        print "rate_down.label rate down\n";
        print "rate_down.draw AREA\n";
    }
    if ( $mode =~ /^switch/ or $is_multi{switch} ) {
        for my $switch ( $mode eq 'multi' ? (1..4):($switch_port) ) {
            print "multigraph freebox_switch_$switch\n" if $mode eq 'multi';
            print "graph_title Freebox port $switch\n";
            print "graph_vlabel Byte / second\n";
            print "switch_rx.label RX rate\n";
            print "switch_tx.label TX rate\n";
            print "graph_category localnet\n";
        }
    }
    if ( shall_print( $mode, 'snr' ) ){
        print "multigraph freebox_snr\n" if $mode eq 'multi';
        print "graph_title Freebox Signal Noise Ratio\n";
        print "graph_vlabel dB\n";
        print "snr_up.label SNR up\n";
        print "snr_down.label SNR down\n";
        print "graph_category xdsl\n";
    }
    if ( shall_print( $mode, 'attn' ) ){
        print "multigraph freebox_attn\n" if $mode eq 'multi';
        print "graph_title Freebox Attenuation\n";
        print "graph_vlabel dB\n";
        print "attn_up.label Attenuation up\n";
        print "attn_down.label Attenuation down\n";
        print "graph_category xdsl\n";
    }
    if ( shall_print( $mode, 'fec' ) ){
        print "multigraph freebox_fec\n" if $mode eq 'multi';
        print "graph_title Freebox Forward Error Correction\n";
        print "graph_vlabel number/min\n";
        print "fec_up.type DERIVE\n";
        print "fec_down.type DERIVE\n";
        print "fec_up.min 0\n";
        print "fec_down.min 0\n";
        print "fec_up.label FEC up\n";
        print "fec_down.label FEC down\n";
        print "graph_category xdsl\n";
    }
    if ( shall_print( $mode, 'fec_up' ) ){
        print "multigraph freebox_fec_up\n" if $mode eq 'multi';
        print "graph_title Freebox Forward Error Correction Up\n";
        print "graph_vlabel number/min\n";
        print "fec_up.type DERIVE\n";
        print "fec_up.min 0\n";
        print "fec_up.label FEC up\n";
        print "graph_category xdsl\n";
    }
    if ( shall_print( $mode, 'fec_down' ) ){
        print "multigraph freebox_fec_down\n" if $mode eq 'multi';
        print "graph_title Freebox Forward Error Correction Down\n";
        print "graph_vlabel number/min\n";
        print "fec_down.type DERIVE\n";
        print "fec_down.min 0\n";
        print "fec_down.label FEC down\n";
        print "graph_category xdsl\n";
    }
    if ( shall_print( $mode, 'uptime' ) ){
        print "multigraph freebox_uptime\n" if $mode eq 'multi';
        print "graph_title Freebox Connection Uptime\n";
        print "graph_vlabel days\n";
        print "graph_args --base 1000 -l 0\n";
        print "graph_scale no\n";
        print "uptime.label uptime\n";
        print "uptime.draw AREA\n";
        print "graph_category freebox\n";
    }
    if ( shall_print( $mode, 'freeplug' ) ){
        print "multigraph freebox_freeplug\n" if $mode eq 'multi';
        print "graph_title Freeplugs connection speed\n";
        print "graph_vlabel Mbit / second\n";
        print "graph_category localnet\n";
        if ( get_freebox->freeplugs_net ) {
          my $fps = get_freebox->freeplugs_net->[0]->{members};

          # Take just the stations as coordinator freeplugs don't have tx/rx stats.
          my @stations = grep { $_->{net_role} eq 'sta' } @$fps;

          if (@stations <= 1) {
              print "freeplug_rx.label receive speed\n";
              print "freeplug_tx.label transmit speed\n";
          } else {
              # If we have more than one station, number them to allow
              # distinguishing between them.
              for (my $fpnum = 1; $fpnum <= @stations; $fpnum++) {
                  print "freeplug${fpnum}_rx.label receive speed for station $fpnum\n";
                  print "freeplug${fpnum}_tx.label transmit speed for station $fpnum\n";
              }
          }
        }
      }
    exit 0
}

sub put_val {
    my ($fb, $what) = @_;
    if ($what eq 'temp') {
        my $sc = $fb->system;
        for my $t (keys %temps) {
            print "$t.value " . $sc->{"temp_$t"} . "\n";
          }
        }
    if ($what eq 'bandwidth') {
        my $cs = $fb->connection;
        print "bandwidth_up.value " . $cs->{"bandwidth_up"}/8 . "\n";
        print "bandwidth_down.value " . $cs->{"bandwidth_down"}/8 . "\n";
      }
    if ($what eq 'comb_up') {
        my $ds = $fb->downloads_stats;
        my $cs = $fb->connection;
        print "rate_up.value " . $cs->{"rate_up"} . "\n";
        print "btrate_up.value " . $ds->{"rx_rate"} . "\n";
      }
    if ($what eq 'comb_down') {
        my $ds = $fb->downloads_stats;
        my $cs = $fb->connection;
        print "rate_down.value " . $cs->{"rate_down"} . "\n";
        print "btrate_down.value " . $ds->{"tx_rate"} . "\n";
      }
    if ($what eq 'btrate_up') {
        my $ds = $fb->downloads_stats;
        print "btrate_up.value " . $ds->{"tx_rate"} . "\n";
        print "btrate_upthr.value " . $ds->{"throttling_rate"}{"tx_rate"} . "\n";
      }
    if ($what eq 'btrate_down') {
        my $ds = $fb->downloads_stats;
        print "btrate_down.value " . $ds->{"rx_rate"} . "\n";
        print "btrate_downthr.value " . $ds->{"throttling_rate"}{"rx_rate"} . "\n";
      }
    if ( $what eq 'up' ) {
        my $cs = $fb->connection;
        print "rate_up.value " . $cs->{"rate_up"} . "\n";
      }
    if ($what eq 'down' ) {
        my $cs = $fb->connection;
        print "rate_down.value " . $cs->{"rate_down"} . "\n";
      }
    if ($what eq 'snr') {
        my $xs = $fb->connection_xdsl;
        print "snr_up.value " . $xs->{up}{snr_10}/10 . "\n";
        print "snr_down.value " . $xs->{down}{snr_10}/10 . "\n";
      }
    if ($what eq 'fec_up' or $what eq 'fec') {
        my $xs = $fb->connection_xdsl;
        print "fec_up.value " . $xs->{up}{fec}*60 . "\n";
      }
    if ($what eq 'fec_down' or $what eq 'fec') {
        my $xs = $fb->connection_xdsl;
        print "fec_down.value " . $xs->{down}{fec}*60 . "\n";
      }
    if ($what eq 'attn') {
        my $xs = $fb->connection_xdsl;
        print "attn_up.value " . $xs->{up}{attn_10}/10 . "\n";
        print "attn_down.value " . $xs->{down}{attn_10}/10 . "\n";
      }
    if ($what eq 'uptime') {
        my $xs = $fb->connection_xdsl;
        printf "uptime.value %.2f\n" , $xs->{status}{uptime}/(3600*24);
      }
    if ($what =~ /^switch/) {
        my $switch_n;
        if ( $mode eq 'multi' ) {
            $switch_n = $1 if $what =~ /switch_(.*)/;
        } else {
            $switch_n = $switch_port;
        }
        my $ss = $fb->switch_port("$switch_n/stats");
        print "switch_rx.value " . $ss->{rx_bytes_rate} . "\n";
        print "switch_tx.value " . $ss->{tx_bytes_rate} . "\n";
      }
    if ($what eq 'freeplug' and $fb->freeplugs_net ) {
        my $try;
        GET_FREEPLUGS: {
            my $fps = $fb->freeplugs_net->[0]{members};

            my @stations = grep { $_->{net_role} eq 'sta' } @$fps;

            last if !@stations;

            # Freeplug stats are invalid if it's not used, so query it once
            # again if it was inactive for some time, this is typically enough
            # to wake it up and get something meaningful from it.
            my $fp = $stations[0];
            redo GET_FREEPLUGS if ++$try < 10 and $fp->{rx_rate} == -1 or $fp->{tx_rate} == -1;

            if (@stations == 1) {
                print "freeplug_rx.value " . $fp->{rx_rate} . "\n";
                print "freeplug_tx.value " . $fp->{tx_rate} . "\n";
            } else {
                my $fpnum = 1;
                for $fp (@stations) {
                    print "freeplug${fpnum}_rx.value " . $fp->{rx_rate} . "\n";
                    print "freeplug${fpnum}_tx.value " . $fp->{tx_rate} . "\n";

                    $fpnum++;
                }
            }
        }
      }
    if ($what eq 'multi') {
        for my $graph ( @multi ) {
            print "multigraph freebox_$graph\n";
            put_val($fb, $graph);
        }
    }
}

die "Usage: $0 [autoconf|config]\n" if @ARGV;

my $fb = get_freebox;
put_val($fb, $mode);

exit 0
#%# family=manual
#%# capabilities=autoconf suggest

